text(x=1:length(cooksd)+1, y=cooksd, labels=ifelse(cooksd>4*mean(cooksd, na.rm=T),names(cooksd),""), col="red")  # add labels
influential <- cooksd>4*mean(cooksd, na.rm=T)  # influential row numbers
stat_df[influential, ]
glmm_residuals <- stat_df[influential, ]
write.csv(glmm_residuals,paste0("Outputs/Meta-regression/LMM_diagnostics/Residuals/Residuals_before_trim",ind[i],model_specs[j],effect_size,currentDate,".csv"))
if (i==1|i==9){ # Carry this to minimise influence of extreme residuals based on rlmer results and overall sample size)
threshold_trim <- 2.5
}else{
threshold_trim <- 3
}
# stat_df <- stat_df %>% mutate(across(c(sel_pred),~Winsorize(., probs = c(0.01, 0.99))))
residual_cutoff <- threshold_trim# extreme residual cutoff
res <- resid(glmm_global, type = "pearson") # Extract standardized residuals
stat_df[abs(res)>residual_cutoff,] # Visualise the residuals to be trimmed
new_data <- romr.fnc(glmm_global, stat_df, trim = residual_cutoff) # Extreme residuals removed to enable better fit
stat_df <- new_data$data #%>% filter(!grepl('Intensive dairy and aquaculture',Scenario..short.description.)) #%>% filter(!grepl('Low_kcal|high meat|high milk',Scenario..short.description.))# Extreme residuals removed to enable better fit
# Refitting model without residuals
glmm_global <- lmer(formula(glmm_global),data=stat_df,REML=TRUE)
tab_model(glmm_global,glmm_global_robust)
check_model(glmm_global)
simulationOutput <- simulateResiduals(fittedModel = glmm_global)
plot(simulationOutput, quantreg = TRUE)
recalc_resid <- recalculateResiduals(simulationOutput, group = stat_df$Model)
plot(recalc_resid, quantreg = TRUE)
png(file=paste0("Outputs/Meta-regression/LMM_diagnostics/Residual_plot_",ind[i],".png"),
width=250, height=200,units='mm',res = 600,pointsize = 20)
predictmeans::residplot(glmm_global, level=1, newwd = FALSE)#, group = "Model") # Residuals plot pop-out
dev.off()
cooksd <- cooks.distance(glmm_global)
plot(cooksd, pch="*", cex=2, main="Influential Obs by Cooks distance")  # plot cook's distance
abline(h = 4*mean(cooksd, na.rm=T), col="red")  # add cutoff line
text(x=1:length(cooksd)+1, y=cooksd, labels=ifelse(cooksd>4*mean(cooksd, na.rm=T),names(cooksd),""), col="red")  # add labels
influential <- cooksd>4*mean(cooksd, na.rm=T)  # influential row numbers
stat_df[influential, ]
glmm_residuals <- stat_df[influential, ]
write.csv(glmm_residuals,paste0("Outputs/Meta-regression/LMM_diagnostics/Residuals/Residuals_after_trim",ind[i],model_specs[j],effect_size,currentDate,".csv"))
source("Functions/CV_GLMM.R")
CV_lmer_results <- CV_GLMM(stat_df,CV_reps,ind,i) # This will return a table with summary results of repeat cross-validation
#CV_lmer_results <- CV # In cases with error run manually
CV_results <- data.frame(CV_lmer_results$RMSE,CV_lmer_results$`NRMSE(RNG)`,CV_lmer_results$AIC,CV_lmer_results$AICc,CV_lmer_results$r2m,CV_lmer_results$r2c)
CV_results
write.csv(CV_results,paste0("Outputs/Meta-regression/Cross_validation/CV_results_",ind[i],model_specs[j],effect_size,currentDate,".csv"))
source("Functions/Visualise_effects.R")# source: Additional model diagnostics - Source: https://ourcodingclub.github.io/tutorials/mixed-models/
saveRDS(glmm_global,paste0("Outputs/Meta-regression/Fitted_models/Models/",ind[i],model_specs[j],effect_size,"_",currentDate,".rds")) # Saving final global model
saveRDS(stat_df,paste0("Outputs/Meta-regression/Fitted_models/Datasets/",ind[i],model_specs[j],currentDate,".rds")) # Saving dataset for prediction
pdf(paste0("Outputs/Meta-regression/LMM_diagnostics/Residuals/",ind[i],model_specs[j],"_",currentDate,"QQplotRES.pdf"))
qqnorm(residuals(glmm_global),main = paste0("GLMMs/Normal Q-Q plot - ",ind[i],model_specs[j]))
dev.off()
#
pdf(paste0("Outputs/Meta-regression/LMM_diagnostics/Residuals/",ind[i],model_specs[j],"_",currentDate,"ScaledRES.pdf"))
plot(glmm_global,main=paste0("GLMMs/",ind[i],model_specs[j], " - residuals"))
dev.off()
# Saving important model information for all three models
#
tab_model(glmm_global,glmm_global_robust,show.aic = TRUE,show.aicc = TRUE,
file = paste0("Outputs/Meta-regression/Model_summaries/",ind[i],model_specs[j],effect_size,"_",currentDate,".html"))
list_CV[[i]][[j]][,1] <- ind[i]
list_CV[[i]][[j]][,2] <- model_specs[j]
list_CV[[i]][[j]][,3] <- CV_lmer_results$RMSE
list_CV[[i]][[j]][,4] <- CV_lmer_results$`NRMSE(RNG)`
list_CV[[i]][[j]][,5] <- CV_lmer_results$AIC
list_CV[[i]][[j]][,6] <- CV_lmer_results$AICc
list_CV[[i]][[j]][,7] <- CV_lmer_results$r2m
list_CV[[i]][[j]][,8] <- CV_lmer_results$r2c
list_CV
Results_list <- do.call(Map, c(f = rbind, list_CV))
Final_results <- do.call(rbind, Results_list)
Final_results
#i <- x
i <- 7# Indicator selection -for testing
j <- 3 # LMM model-type for testing (default=3)
if(i==2){
effect_size="delta (%)"
} else {
effect_size <- 'lnR'# Whether the difference from the baseline/BAU should be a multiplier or absolute difference
}
df_stat <- DF[!is.na(DF[,ind[i]]),] %>% #%>% filter(Scenario.year..numeric.==2050)# filtering only rows that have indicator values
#filter(ScenYear<2051) %>% # Only consider data up to 2050 (reduces sample size but tightens the study scope)
filter(Included=="Yes") %>%  # Some papers with very incomplete data are excluded completely
#mutate(Aqua_kcal = replace_na(Aqua_kcal, 0)) %>%
mutate(Scope = dplyr::recode (Scope, # Recoding to create factor with two levels (Food & Agriculture)
`Food production`= "Food",
`Food system` = "Food",
`AFOLU` = "Agriculture")) %>%
data.frame() # Converting to data.frame if tibble
# Trimming outliers and cleaning up
source("Functions/Study_selection.R")
df_stat <- select_studies(df_stat,i)
stat_df <- df_stat %>% # Cleaning dataframe
dplyr::select(any_of(c("Study","Model","ScenYear","Scope","Cropland.scope","Pasture.scope","Water.scope","Scen_desc",
"Scenario..author.code.","C_price_cat",ind[[i]],list_var[[i]][[j]]))) %>%  # Selecting only relevant columns
mutate(Study=as.factor(Study)) %>% # Ensuring that random intercept ID is a factor
mutate(Model=as.factor(Model)) %>%  # Ensuring that random intercept ID is a factor
mutate(Scope=as.factor(Scope)) %>% # Scope also adjusted to ensure it's a factor
group_by(Study) %>%
mutate(Initial_condition = first(!!sym(ind[[i]]))) %>% # Adding initial condition (base year value)
mutate(Delta_initial = first(!!sym(ind[[i]]))-value_base_year[i]) %>% # Adding base year delta
ungroup()
pred_index <- list_var[[i]][[j]] %notin% c("Organic","C_price","WPinc","GHG_eff_CH4","GHG_eff_N2O","GHG_eff_all",
"Cropland.scope","Pasture.scope","NUEinc","NrecHousehold",
"PUEinc","PrecHousehold") # Removing indicators where relative change is meaningless (start at zero)
sel_pred <- list_var[[i]][[j]][pred_index] # Selecting model predictors
sel_pred_plus <- c(sel_pred,base_year_norm)
if(model_change=="yes"){ # If user decides to model change instead of absolute numbers (default is to model change as a multiplier)
source("Functions/Effect_size_normalisation.R")
stat_df <- ES_metric(ind,stat_df,effect_size,sel_pred)
}
if(trim_outliers=="yes"){ # If yes, extreme outliers are trimmed - creating a more normal distribution
source("Functions/Trim_outliers.R")
stat_df <- trim_residuals(stat_df,ind,i)
}
## GLOBAL MODELS - Model fitted with lmer (Regulation not significant)
if (i==1){
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Cropland.scope","Initial_condition","Delta_initial","C_price_cat",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na() # Dropping NAs before fitting models
} else if (i==2){
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Pasture.scope","Initial_condition","Delta_initial","C_price_cat",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na() # Dropping NAs before fitting models
} else if (i==3) {
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Water.scope","Initial_condition","Delta_initial",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na()
} else {
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Initial_condition","Delta_initial",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na()
}
m0.glm <- glm(stat_df[,ind[i]] ~ 1, family = gaussian, data = stat_df) # Simple linear model
m0.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (1|Model), data = stat_df) # Linear mixed model with model/study as intercept
# m1.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (1+Yield+WPinc|Model), data = stat_df) # Linear mixed model with model and study as intercepts
# m2.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (WPinc|Model) + (Yield|Model), data = stat_df)
# m3.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (WPinc||Model) + (Yield||Model), data = stat_df)
#
AIC(logLik(m0.glm))
AIC(logLik(m0.lmer))
anova(m0.glm,m0.lmer)
All_preds <- paste0(list_par[[i]][[j]],"+ scale(",base_year_norm,")")#,"+ C_price_cat") # Adding C_price cat (where relevant)
if(i==3|i==5){
#glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Rum_feed_grass|Model)"),data=stat_df,REML=TRUE)
glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE)
glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
r.squaredGLMM(glmm_global)
#} else if(i==3) {
#  glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield||Model) + (Plant_food_water||Model)"),data=stat_df,REML=TRUE)
#  glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield||Model) + (WPinc||Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
# glmm_global1 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model) + (Yield+0|Model) + (WPinc+0|Model)"),data=stat_df,REML=TRUE)
# glmm_global2 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield+WPinc|Model)"),data=stat_df,REML=TRUE)
# glmm_global3 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield|Model) + (WPinc|Model)"),data=stat_df,REML=TRUE)
# glmm_global4 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE)
#
# a <- brm(paste0(ind[i]," ~ ",All_preds,"+ (Yield + WPinc|Model)"),data=stat_df)
} else {
glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model)"),data=stat_df,REML=TRUE)
glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
r.squaredGLMM(glmm_global)
}
#glmm_global1 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield||Model)"),data=stat_df,REML=TRUE) uncorrelated intercept and slope
check_model(glmm_global)
tab_model(glmm_global,glmm_global_robust)
# Calling 'model_par' function that provides model specification for each indicator model
source("Functions/Model_parameterisation.R")
list_var <- model_par(ind)
if(scale_predictors=="yes"){ # If user decides to model change instead of absolute numbers (default is to model change as a multiplier)
list_par <- lapply(seq_along(list_var),function(x)
lapply(1:3,function(y) paste0("scale(",list_var[[x]][[y]],")") %>% str_c(collapse = " + ")))
} else { # If effect size is % change
list_par <- lapply(seq_along(list_var),function(x)
lapply(1:3,function(y) paste0(list_var[[x]][[y]]) %>% str_c(collapse = " + ")))
}
#Key predictors vector - Key predictors for plotting against each indicator (can be modified)
key_preds <- c("Yield","Rum_feed_grass","WPinc","Rum_meat_kcal_GHG","Yield","NUEinc","NUEinc","PUEinc","PUEinc")
key_preds_string <- c("Crop yields","Ruminant grass feed","Water use efficiency","Ruminant meat","Crop yields",
"Nitrogen use efficiency","Nitrogen use efficiency",
"Phosphorus use efficiency","Phoshorus use efficiency")
#i <- x
i <- 7# Indicator selection -for testing
j <- 3 # LMM model-type for testing (default=3)
if(i==2){
effect_size="delta (%)"
} else {
effect_size <- 'lnR'# Whether the difference from the baseline/BAU should be a multiplier or absolute difference
}
df_stat <- DF[!is.na(DF[,ind[i]]),] %>% #%>% filter(Scenario.year..numeric.==2050)# filtering only rows that have indicator values
#filter(ScenYear<2051) %>% # Only consider data up to 2050 (reduces sample size but tightens the study scope)
filter(Included=="Yes") %>%  # Some papers with very incomplete data are excluded completely
#mutate(Aqua_kcal = replace_na(Aqua_kcal, 0)) %>%
mutate(Scope = dplyr::recode (Scope, # Recoding to create factor with two levels (Food & Agriculture)
`Food production`= "Food",
`Food system` = "Food",
`AFOLU` = "Agriculture")) %>%
data.frame() # Converting to data.frame if tibble
# Trimming outliers and cleaning up
source("Functions/Study_selection.R")
df_stat <- select_studies(df_stat,i)
stat_df <- df_stat %>% # Cleaning dataframe
dplyr::select(any_of(c("Study","Model","ScenYear","Scope","Cropland.scope","Pasture.scope","Water.scope","Scen_desc",
"Scenario..author.code.","C_price_cat",ind[[i]],list_var[[i]][[j]]))) %>%  # Selecting only relevant columns
mutate(Study=as.factor(Study)) %>% # Ensuring that random intercept ID is a factor
mutate(Model=as.factor(Model)) %>%  # Ensuring that random intercept ID is a factor
mutate(Scope=as.factor(Scope)) %>% # Scope also adjusted to ensure it's a factor
group_by(Study) %>%
mutate(Initial_condition = first(!!sym(ind[[i]]))) %>% # Adding initial condition (base year value)
mutate(Delta_initial = first(!!sym(ind[[i]]))-value_base_year[i]) %>% # Adding base year delta
ungroup()
pred_index <- list_var[[i]][[j]] %notin% c("Organic","C_price","WPinc","GHG_eff_CH4","GHG_eff_N2O","GHG_eff_all",
"Cropland.scope","Pasture.scope","NUEinc","NrecHousehold",
"PUEinc","PrecHousehold") # Removing indicators where relative change is meaningless (start at zero)
sel_pred <- list_var[[i]][[j]][pred_index] # Selecting model predictors
sel_pred_plus <- c(sel_pred,base_year_norm)
if(model_change=="yes"){ # If user decides to model change instead of absolute numbers (default is to model change as a multiplier)
source("Functions/Effect_size_normalisation.R")
stat_df <- ES_metric(ind,stat_df,effect_size,sel_pred)
}
if(trim_outliers=="yes"){ # If yes, extreme outliers are trimmed - creating a more normal distribution
source("Functions/Trim_outliers.R")
stat_df <- trim_residuals(stat_df,ind,i)
}
if(diagnostic_plots=="yes"){ # if enables, plots all models/studies, histogram of indicator and relationship between chosen dependent variable and indicator
source("Functions/Exploratory_plot.R")
exploratory_plots(stat_df,key_preds,key_preds_string,ind,i)
}
## GLOBAL MODELS - Model fitted with lmer (Regulation not significant)
if (i==1){
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Cropland.scope","Initial_condition","Delta_initial","C_price_cat",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na() # Dropping NAs before fitting models
} else if (i==2){
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Pasture.scope","Initial_condition","Delta_initial","C_price_cat",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na() # Dropping NAs before fitting models
} else if (i==3) {
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Water.scope","Initial_condition","Delta_initial",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na()
} else {
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Initial_condition","Delta_initial",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na()
}
m0.glm <- glm(stat_df[,ind[i]] ~ 1, family = gaussian, data = stat_df) # Simple linear model
m0.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (1|Model), data = stat_df) # Linear mixed model with model/study as intercept
# m1.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (1+Yield+WPinc|Model), data = stat_df) # Linear mixed model with model and study as intercepts
# m2.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (WPinc|Model) + (Yield|Model), data = stat_df)
# m3.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (WPinc||Model) + (Yield||Model), data = stat_df)
#
AIC(logLik(m0.glm))
AIC(logLik(m0.lmer))
anova(m0.glm,m0.lmer)
All_preds <- paste0(list_par[[i]][[j]],"+ scale(",base_year_norm,")")#,"+ C_price_cat") # Adding C_price cat (where relevant)
if(i==3|i==5){
#glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Rum_feed_grass|Model)"),data=stat_df,REML=TRUE)
glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE)
glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
r.squaredGLMM(glmm_global)
#} else if(i==3) {
#  glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield||Model) + (Plant_food_water||Model)"),data=stat_df,REML=TRUE)
#  glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield||Model) + (WPinc||Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
# glmm_global1 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model) + (Yield+0|Model) + (WPinc+0|Model)"),data=stat_df,REML=TRUE)
# glmm_global2 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield+WPinc|Model)"),data=stat_df,REML=TRUE)
# glmm_global3 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield|Model) + (WPinc|Model)"),data=stat_df,REML=TRUE)
# glmm_global4 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE)
#
# a <- brm(paste0(ind[i]," ~ ",All_preds,"+ (Yield + WPinc|Model)"),data=stat_df)
} else {
glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model)"),data=stat_df,REML=TRUE)
glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
r.squaredGLMM(glmm_global)
}
#glmm_global1 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield||Model)"),data=stat_df,REML=TRUE) uncorrelated intercept and slope
check_model(glmm_global)
tab_model(glmm_global,glmm_global_robust)
#i <- x
i <- 2# Indicator selection -for testing
j <- 3 # LMM model-type for testing (default=3)
if(i==2){
effect_size="delta (%)"
} else {
effect_size <- 'lnR'# Whether the difference from the baseline/BAU should be a multiplier or absolute difference
}
df_stat <- DF[!is.na(DF[,ind[i]]),] %>% #%>% filter(Scenario.year..numeric.==2050)# filtering only rows that have indicator values
#filter(ScenYear<2051) %>% # Only consider data up to 2050 (reduces sample size but tightens the study scope)
filter(Included=="Yes") %>%  # Some papers with very incomplete data are excluded completely
#mutate(Aqua_kcal = replace_na(Aqua_kcal, 0)) %>%
mutate(Scope = dplyr::recode (Scope, # Recoding to create factor with two levels (Food & Agriculture)
`Food production`= "Food",
`Food system` = "Food",
`AFOLU` = "Agriculture")) %>%
data.frame() # Converting to data.frame if tibble
# Trimming outliers and cleaning up
source("Functions/Study_selection.R")
df_stat <- select_studies(df_stat,i)
stat_df <- df_stat %>% # Cleaning dataframe
dplyr::select(any_of(c("Study","Model","ScenYear","Scope","Cropland.scope","Pasture.scope","Water.scope","Scen_desc",
"Scenario..author.code.","C_price_cat",ind[[i]],list_var[[i]][[j]]))) %>%  # Selecting only relevant columns
mutate(Study=as.factor(Study)) %>% # Ensuring that random intercept ID is a factor
mutate(Model=as.factor(Model)) %>%  # Ensuring that random intercept ID is a factor
mutate(Scope=as.factor(Scope)) %>% # Scope also adjusted to ensure it's a factor
group_by(Study) %>%
mutate(Initial_condition = first(!!sym(ind[[i]]))) %>% # Adding initial condition (base year value)
mutate(Delta_initial = first(!!sym(ind[[i]]))-value_base_year[i]) %>% # Adding base year delta
ungroup()
pred_index <- list_var[[i]][[j]] %notin% c("Organic","C_price","WPinc","GHG_eff_CH4","GHG_eff_N2O","GHG_eff_all",
"Cropland.scope","Pasture.scope","NUEinc","NrecHousehold",
"PUEinc","PrecHousehold") # Removing indicators where relative change is meaningless (start at zero)
sel_pred <- list_var[[i]][[j]][pred_index] # Selecting model predictors
sel_pred_plus <- c(sel_pred,base_year_norm)
if(model_change=="yes"){ # If user decides to model change instead of absolute numbers (default is to model change as a multiplier)
source("Functions/Effect_size_normalisation.R")
stat_df <- ES_metric(ind,stat_df,effect_size,sel_pred)
}
if(trim_outliers=="yes"){ # If yes, extreme outliers are trimmed - creating a more normal distribution
source("Functions/Trim_outliers.R")
stat_df <- trim_residuals(stat_df,ind,i)
}
## GLOBAL MODELS - Model fitted with lmer (Regulation not significant)
if (i==1){
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Cropland.scope","Initial_condition","Delta_initial","C_price_cat",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na() # Dropping NAs before fitting models
} else if (i==2){
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Pasture.scope","Initial_condition","Delta_initial","C_price_cat",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na() # Dropping NAs before fitting models
} else if (i==3) {
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Water.scope","Initial_condition","Delta_initial",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na()
} else {
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Initial_condition","Delta_initial",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na()
}
m0.glm <- glm(stat_df[,ind[i]] ~ 1, family = gaussian, data = stat_df) # Simple linear model
m0.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (1|Model), data = stat_df) # Linear mixed model with model/study as intercept
# m1.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (1+Yield+WPinc|Model), data = stat_df) # Linear mixed model with model and study as intercepts
# m2.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (WPinc|Model) + (Yield|Model), data = stat_df)
# m3.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (WPinc||Model) + (Yield||Model), data = stat_df)
#
AIC(logLik(m0.glm))
AIC(logLik(m0.lmer))
anova(m0.glm,m0.lmer)
All_preds <- paste0(list_par[[i]][[j]],"+ scale(",base_year_norm,")")#,"+ C_price_cat") # Adding C_price cat (where relevant)
if(i==3|i==5){
#glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Rum_feed_grass|Model)"),data=stat_df,REML=TRUE)
glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE)
glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
r.squaredGLMM(glmm_global)
#} else if(i==3) {
#  glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield||Model) + (Plant_food_water||Model)"),data=stat_df,REML=TRUE)
#  glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield||Model) + (WPinc||Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
# glmm_global1 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model) + (Yield+0|Model) + (WPinc+0|Model)"),data=stat_df,REML=TRUE)
# glmm_global2 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield+WPinc|Model)"),data=stat_df,REML=TRUE)
# glmm_global3 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield|Model) + (WPinc|Model)"),data=stat_df,REML=TRUE)
# glmm_global4 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE)
#
# a <- brm(paste0(ind[i]," ~ ",All_preds,"+ (Yield + WPinc|Model)"),data=stat_df)
} else {
glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model)"),data=stat_df,REML=TRUE)
glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
r.squaredGLMM(glmm_global)
}
#glmm_global1 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield||Model)"),data=stat_df,REML=TRUE) uncorrelated intercept and slope
check_model(glmm_global)
tab_model(glmm_global,glmm_global_robust)
## 3.4 Checking alternative fixed effect structures - stepwise elimination not used anymore since cross-validation was introduced
# Dropping variables to see effect on AIC and LRT
#
drop1(glmm_global,test="Chisq")
#
# }else{
#
#   alpha_fixed=0.2
# }
#
# glmm_global <- step(glmm_global,reduce.random = FALSE,alpha.fixed = alpha_fixed) %>% get_model() # Choosing model after inspecting drop1 results
# write.csv(drop1(glmm_global,test="Chisq"),paste0("Outputs/Meta-regression/LMM_diagnostics/Drop1/Drop1",ind[i],model_specs[j],effect_size,currentDate,".csv"))
#
# Checking for colinearity
VIF_glmm <- as.data.frame(vif(glmm_global))
#VIF_glmm$`GVIF^(1/(2*Df))` <- VIF_glmm$`GVIF^(1/(2*Df))`^2 # Squaring last column as per: https://stats.stackexchange.com/questions/70679/which-variance-inflation-factor-should-i-be-using-textgvif-or-textgvif
#colnames(VIF_glmm) <- c("Variable","VIF")
VIF_glmm
if (i==1|i==9){ # Carry this to minimise influence of extreme residuals based on rlmer results and overall sample size)
threshold_trim <- 2.5
}else{
threshold_trim <- 3
}
# stat_df <- stat_df %>% mutate(across(c(sel_pred),~Winsorize(., probs = c(0.01, 0.99))))
residual_cutoff <- threshold_trim# extreme residual cutoff
res <- resid(glmm_global, type = "pearson") # Extract standardized residuals
stat_df[abs(res)>residual_cutoff,] # Visualise the residuals to be trimmed
new_data <- romr.fnc(glmm_global, stat_df, trim = residual_cutoff) # Extreme residuals removed to enable better fit
stat_df <- new_data$data #%>% filter(!grepl('Intensive dairy and aquaculture',Scenario..short.description.)) #%>% filter(!grepl('Low_kcal|high meat|high milk',Scenario..short.description.))# Extreme residuals removed to enable better fit
# Refitting model without residuals
glmm_global <- lmer(formula(glmm_global),data=stat_df,REML=TRUE)
tab_model(glmm_global,glmm_global_robust)
tab_model(glmm_global,glmm_global_robust)
check_model(glmm_global)
source("Functions/CV_GLMM.R")
CV_lmer_results <- CV_GLMM(stat_df,CV_reps,ind,i) # This will return a table with summary results of repeat cross-validation
#CV_lmer_results <- CV # In cases with error run manually
CV_results <- data.frame(CV_lmer_results$RMSE,CV_lmer_results$`NRMSE(RNG)`,CV_lmer_results$AIC,CV_lmer_results$AICc,CV_lmer_results$r2m,CV_lmer_results$r2c)
CV_results
glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Rum_feed_grass|Model)"),data=stat_df,REML=TRUE)
r.squaredGLMM(glmm_global)
tab_model(glmm_global,glmm_global_robust)
#glmm_global1 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield||Model)"),data=stat_df,REML=TRUE) uncorrelated intercept and slope
check_model(glmm_global)
if (i==1|i==9){ # Carry this to minimise influence of extreme residuals based on rlmer results and overall sample size)
threshold_trim <- 2.5
}else{
threshold_trim <- 3
}
# stat_df <- stat_df %>% mutate(across(c(sel_pred),~Winsorize(., probs = c(0.01, 0.99))))
residual_cutoff <- threshold_trim# extreme residual cutoff
res <- resid(glmm_global, type = "pearson") # Extract standardized residuals
stat_df[abs(res)>residual_cutoff,] # Visualise the residuals to be trimmed
new_data <- romr.fnc(glmm_global, stat_df, trim = residual_cutoff) # Extreme residuals removed to enable better fit
stat_df <- new_data$data #%>% filter(!grepl('Intensive dairy and aquaculture',Scenario..short.description.)) #%>% filter(!grepl('Low_kcal|high meat|high milk',Scenario..short.description.))# Extreme residuals removed to enable better fit
# Refitting model without residuals
glmm_global <- lmer(formula(glmm_global),data=stat_df,REML=TRUE)
tab_model(glmm_global,glmm_global_robust)
check_model(glmm_global)
simulationOutput <- simulateResiduals(fittedModel = glmm_global)
source("Functions/CV_GLMM.R")
CV_lmer_results <- CV_GLMM(stat_df,CV_reps,ind,i) # This will return a table with summary results of repeat cross-validation
CV_results
#CV_lmer_results <- CV # In cases with error run manually
CV_results <- data.frame(CV_lmer_results$RMSE,CV_lmer_results$`NRMSE(RNG)`,CV_lmer_results$AIC,CV_lmer_results$AICc,CV_lmer_results$r2m,CV_lmer_results$r2c)
CV_results
#i <- x
i <- 2# Indicator selection -for testing
j <- 3 # LMM model-type for testing (default=3)
if(i==2){
effect_size="delta (%)"
} else {
effect_size <- 'lnR'# Whether the difference from the baseline/BAU should be a multiplier or absolute difference
}
df_stat <- DF[!is.na(DF[,ind[i]]),] %>% #%>% filter(Scenario.year..numeric.==2050)# filtering only rows that have indicator values
#filter(ScenYear<2051) %>% # Only consider data up to 2050 (reduces sample size but tightens the study scope)
filter(Included=="Yes") %>%  # Some papers with very incomplete data are excluded completely
#mutate(Aqua_kcal = replace_na(Aqua_kcal, 0)) %>%
mutate(Scope = dplyr::recode (Scope, # Recoding to create factor with two levels (Food & Agriculture)
`Food production`= "Food",
`Food system` = "Food",
`AFOLU` = "Agriculture")) %>%
data.frame() # Converting to data.frame if tibble
# Trimming outliers and cleaning up
source("Functions/Study_selection.R")
df_stat <- select_studies(df_stat,i)
stat_df <- df_stat %>% # Cleaning dataframe
dplyr::select(any_of(c("Study","Model","ScenYear","Scope","Cropland.scope","Pasture.scope","Water.scope","Scen_desc",
"Scenario..author.code.","C_price_cat",ind[[i]],list_var[[i]][[j]]))) %>%  # Selecting only relevant columns
mutate(Study=as.factor(Study)) %>% # Ensuring that random intercept ID is a factor
mutate(Model=as.factor(Model)) %>%  # Ensuring that random intercept ID is a factor
mutate(Scope=as.factor(Scope)) %>% # Scope also adjusted to ensure it's a factor
group_by(Study) %>%
mutate(Initial_condition = first(!!sym(ind[[i]]))) %>% # Adding initial condition (base year value)
mutate(Delta_initial = first(!!sym(ind[[i]]))-value_base_year[i]) %>% # Adding base year delta
ungroup()
pred_index <- list_var[[i]][[j]] %notin% c("Organic","C_price","WPinc","GHG_eff_CH4","GHG_eff_N2O","GHG_eff_all",
"Cropland.scope","Pasture.scope","NUEinc","NrecHousehold",
"PUEinc","PrecHousehold") # Removing indicators where relative change is meaningless (start at zero)
sel_pred <- list_var[[i]][[j]][pred_index] # Selecting model predictors
sel_pred_plus <- c(sel_pred,base_year_norm)
if(model_change=="yes"){ # If user decides to model change instead of absolute numbers (default is to model change as a multiplier)
source("Functions/Effect_size_normalisation.R")
stat_df <- ES_metric(ind,stat_df,effect_size,sel_pred)
}
if(trim_outliers=="yes"){ # If yes, extreme outliers are trimmed - creating a more normal distribution
source("Functions/Trim_outliers.R")
stat_df <- trim_residuals(stat_df,ind,i)
}
## GLOBAL MODELS - Model fitted with lmer (Regulation not significant)
if (i==1){
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Cropland.scope","Initial_condition","Delta_initial","C_price_cat",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na() # Dropping NAs before fitting models
} else if (i==2){
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Pasture.scope","Initial_condition","Delta_initial","C_price_cat",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na() # Dropping NAs before fitting models
} else if (i==3) {
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Water.scope","Initial_condition","Delta_initial",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na()
} else {
stat_df <- stat_df %>% dplyr::select(any_of(c("Study","ScenYear","Model","Scope","Scenario..author.code.","Initial_condition","Delta_initial",
ind[[i]],list_var[[i]][[j]]))) %>% drop_na()
}
m0.glm <- glm(stat_df[,ind[i]] ~ 1, family = gaussian, data = stat_df) # Simple linear model
m0.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (1|Model), data = stat_df) # Linear mixed model with model/study as intercept
# m1.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (1+Yield+WPinc|Model), data = stat_df) # Linear mixed model with model and study as intercepts
# m2.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (WPinc|Model) + (Yield|Model), data = stat_df)
# m3.lmer <- lmer(stat_df[,ind[i]] ~ 1 + (WPinc||Model) + (Yield||Model), data = stat_df)
#
AIC(logLik(m0.glm))
AIC(logLik(m0.lmer))
anova(m0.glm,m0.lmer)
All_preds <- paste0(list_par[[i]][[j]],"+ scale(",base_year_norm,")")#,"+ C_price_cat") # Adding C_price cat (where relevant)
if(i==3|i==5){
#glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Rum_feed_grass|Model)"),data=stat_df,REML=TRUE) # Testing for pasture
glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE)
glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
r.squaredGLMM(glmm_global)
#} else if(i==3) {
#  glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield||Model) + (Plant_food_water||Model)"),data=stat_df,REML=TRUE)
#  glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield||Model) + (WPinc||Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
# glmm_global1 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model) + (Yield+0|Model) + (WPinc+0|Model)"),data=stat_df,REML=TRUE)
# glmm_global2 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield+WPinc|Model)"),data=stat_df,REML=TRUE)
# glmm_global3 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (Yield|Model) + (WPinc|Model)"),data=stat_df,REML=TRUE)
# glmm_global4 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield|Model)"),data=stat_df,REML=TRUE)
#
# a <- brm(paste0(ind[i]," ~ ",All_preds,"+ (Yield + WPinc|Model)"),data=stat_df)
} else {
glmm_global <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model)"),data=stat_df,REML=TRUE)
glmm_global_robust <- rlmer(paste0(ind[i]," ~ ",All_preds,"+ (1|Model)"),data=stat_df,REML=TRUE) # RobustLMM version (less sensitive to outliers, heteroscedasticity and heterogeneity of variance)
r.squaredGLMM(glmm_global)
}
#glmm_global1 <- lmer(paste0(ind[i]," ~ ",All_preds,"+ (1+Yield||Model)"),data=stat_df,REML=TRUE) uncorrelated intercept and slope
check_model(glmm_global)
tab_model(glmm_global,glmm_global_robust)
source("Functions/CV_GLMM.R")
CV_lmer_results <- CV_GLMM(stat_df,CV_reps,ind,i) # This will return a table with summary results of repeat cross-validation
source("//school-les-m.shares.deakin.edu.au/school-les-m/Planet-A/Food-Systems/Meta_analysis/GFSI-MRM/GFSI-MRM/Scripts/2.0_Predict_scenario.R")
